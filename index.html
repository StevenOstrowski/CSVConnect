<!DOCTYPE html>
<html>
<head>
    <title>CSV Loader Pro</title>
    <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; padding: 15px; background: #fff; color: #333; }
        #drop-zone {
            border: 2px dashed #0078d4; border-radius: 8px; padding: 25px 10px;
            text-align: center; background: #f0f7ff; cursor: pointer; transition: 0.3s;
        }
        #drop-zone.hover { background: #d0e7ff; }
        .btn { 
            color: white; border: none; padding: 10px; 
            width: 100%; cursor: pointer; border-radius: 2px; margin-top: 8px; font-weight: bold;
        }
        .btn-zoom { background: #107c10; }
        .btn-clear { background: #d83b01; }
        #status { margin-top: 15px; font-size: 13px; font-weight: 500; }
        .success { color: #107c10; }
        .error { color: #d83b01; border-left: 3px solid #d83b01; padding-left: 5px; }
        .sample-link { display: block; margin-top: 20px; font-size: 11px; color: #0078d4; text-decoration: none; text-align: center;}
    </style>
</head>
<body>
    <h3>CSV Point Loader</h3>
    
    <div id="drop-zone">
        <p><b>Drag & Drop CSV</b><br>or click to browse</p>
        <input type="file" id="fileInput" accept=".csv" style="display:none">
    </div>

    <div id="status">Connecting...</div>

    <button class="btn btn-zoom" onclick="zoomToPoints()">üî≠ Zoom to Points</button>
    <button class="btn btn-clear" onclick="clearPoints()">üóëÔ∏è Clear All</button>

    <script>
        let connectAPI;
        let loadedPointIds = [];
        let pointPositions = [];

        async function init() {
            try {
                connectAPI = await TrimbleConnectWorkspace.connect(window.parent);
                document.getElementById('status').innerText = "Connected! Please ensure a model is visible.";
            } catch (e) { 
                document.getElementById('status').innerText = "Connection failed."; 
            }
        }

        const dz = document.getElementById('drop-zone');
        const fi = document.getElementById('fileInput');
        dz.onclick = () => fi.click();
        dz.ondragover = (e) => { e.preventDefault(); dz.classList.add('hover'); };
        dz.ondragleave = () => dz.classList.remove('hover');
        dz.ondrop = (e) => {
            e.preventDefault();
            dz.classList.remove('hover');
            if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
        };
        fi.onchange = (e) => { if (e.target.files.length) handleFile(e.target.files[0]); };

        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = (event) => processCSV(event.target.result);
            reader.readAsText(file);
        }

       async function processCSV(data) {
    const rows = data.split(/\r?\n/);
    const markers = [];
    pointPositions = [];

    rows.forEach((row, i) => {
        const cols = row.split(',');
        if (cols.length >= 4) {
            const [name, x, y, z] = cols.map(c => c.trim());
            const px = parseFloat(x), py = parseFloat(y), pz = parseFloat(z);
            if (!isNaN(px)) {
                const id = "pt_" + Date.now() + "_" + i;
                const pos = { x: px, y: py, z: pz };
                markers.push({ 
                    id: id, 
                    title: name || `Pt ${i}`, 
                    position: pos, 
                    color: "#FF0000" 
                });
                loadedPointIds.push(id);
                pointPositions.push(pos);
            }
        }
    });

    if (markers.length > 0) {
        try {
            // COMPATIBILITY LAYER: Try all 3 known Trimble API methods for icons
            if (connectAPI.viewer.icons && typeof connectAPI.viewer.icons.add === 'function') {
                await connectAPI.viewer.icons.add(markers); // Modern API
            } else if (typeof connectAPI.viewer.addIcon === 'function') {
                await connectAPI.viewer.addIcon(markers); // Older API
            } else if (connectAPI.viewer.objects && typeof connectAPI.viewer.objects.addIcon === 'function') {
                await connectAPI.viewer.objects.addIcon(markers); // Alternate API
            } else {
                throw new Error("Icon module not found. Please check Extension Permissions.");
            }

            document.getElementById('status').innerHTML = `<span class="success">Successfully loaded ${markers.length} points!</span>`;
        } catch (err) {
            document.getElementById('status').innerHTML = `<span class="error">Viewer Error: ${err.message}</span>`;
            console.error("Full Error Object:", err);
        }
    }
}async function processCSV(data) {
    const rows = data.split(/\r?\n/);
    const markers = [];
    pointPositions = [];

    rows.forEach((row, i) => {
        const cols = row.split(',');
        if (cols.length >= 4) {
            const [name, x, y, z] = cols.map(c => c.trim());
            const px = parseFloat(x), py = parseFloat(y), pz = parseFloat(z);
            if (!isNaN(px)) {
                const id = "pt_" + Date.now() + "_" + i;
                const pos = { x: px, y: py, z: pz };
                markers.push({ 
                    id: id, 
                    title: name || `Pt ${i}`, 
                    position: pos, 
                    color: "#FF0000" 
                });
                loadedPointIds.push(id);
                pointPositions.push(pos);
            }
        }
    });

    if (markers.length > 0) {
        try {
            // COMPATIBILITY LAYER: Try all 3 known Trimble API methods for icons
            if (connectAPI.viewer.icons && typeof connectAPI.viewer.icons.add === 'function') {
                await connectAPI.viewer.icons.add(markers); // Modern API
            } else if (typeof connectAPI.viewer.addIcon === 'function') {
                await connectAPI.viewer.addIcon(markers); // Older API
            } else if (connectAPI.viewer.objects && typeof connectAPI.viewer.objects.addIcon === 'function') {
                await connectAPI.viewer.objects.addIcon(markers); // Alternate API
            } else {
                throw new Error("Icon module not found. Please check Extension Permissions.");
            }

            document.getElementById('status').innerHTML = `<span class="success">Successfully loaded ${markers.length} points!</span>`;
        } catch (err) {
            document.getElementById('status').innerHTML = `<span class="error">Viewer Error: ${err.message}</span>`;
            console.error("Full Error Object:", err);
        }
    }
}

            if (markers.length > 0) {
                try {
                    await connectAPI.viewer.icons.add(markers);
                    document.getElementById('status').innerHTML = `<span class="success">Successfully loaded ${markers.length} points!</span>`;
                } catch (err) {
                    // This is where the "No models loaded" error usually surfaces
                    document.getElementById('status').innerHTML = `<span class="error">Viewer Error: ${err.message}<br>Make sure at least one model is visible in the viewer!</span>`;
                }
            }
        }

        async function zoomToPoints() {
            if (pointPositions.length === 0) return;
            const avg = pointPositions.reduce((acc, p) => ({x: acc.x + p.x, y: acc.y + p.y, z: acc.z + p.z}), {x:0, y:0, z:0});
            const center = { x: avg.x/pointPositions.length, y: avg.y/pointPositions.length, z: avg.z/pointPositions.length };
            await connectAPI.viewer.camera.setTarget(center);
        }

        async function clearPoints() {
            if (loadedPointIds.length > 0) {
                try {
                    await connectAPI.viewer.icons.remove(loadedPointIds);
                    loadedPointIds = [];
                    pointPositions = [];
                    document.getElementById('status').innerText = "Cleared.";
                } catch(e) { document.getElementById('status').innerText = "Error clearing."; }
            }
        }

        init();
    </script>
</body>
</html>

